TODOS:
- add minishell: to syntax error
- rm error multiple file redirs in parsing
- add expansions/full parsing inside heredoc
- get rid of all debug prints
- ctrl-C not direct

open test cases

|                    # Syntax error: single pipe
ls |                # Syntax error: nothing after pipe
> output.txt        # Syntax error: no command
<                   # Syntax error: no file

ls >>> file         # Syntax error: invalid operator
- cat << EOF > file1.log
    opens and closes heredoc ok, but does not write to file
- ./nonexistent_command
    produces leaks
- leaks for: echo hello | cat echo hello | cat
- working with leaks: cat << EOF    # Then press Ctrl+C during heredoc
./exeNoPermission --> prints minishell: ./EOF: Permission denied
                             mariashell: ./EOF: command not found (bash does not print this one)
export ""          # Empty string error for empty string ? --> prduces: Error parsing commands
only spaces or tabs --> gives back prompt but prints new line, no cmds created
cat <<EOF 1>>out.log  --> append does not creat the file if it doesnt exist yet

exit 42 --> does not actually exit
mariashell > echo dfsf >"" --> minishell: : Permission denied instead of inexistent file
??? on input not yet entered, when pressing ctrl-C, its not printed in teh prompt -> bash:    sh-5.2$ cat dfsd ^C

EDGE CASE NOT TO FIX:
- export TEST=value : subsequent parsing is wrong for quoted arguments



WORKING COMMANDS:

ls
pwd
echo hello
/bin/ls
echo $PATH
echo "$PATH"
echo '$PATH'            # Should print literal $PATH
echo $?                # Last exit status
echo "hello 'world'"
echo 'hello "world"'
echo "hello $USER"     # Variable expansion in double quotes
echo 'hello $USER'     # No variable expansion in single quotes
echo $HOME"test"'$USER'
echo $HOME"test""$USER"
echo hello > output.txt
cat < input.txt
echo hello >> output.txt
cat << EOF             # Heredoc
cd /path/to/dir
cd ..
cd ~
pwd
unset TEST
exit 42
echo $HOME"test"'$USER'
echo hello > f1 | cat < f2    # Pipe with redirections, should write to f1 and print f2 content,
env | grep TEST
echo hello | cat
cat file.txt | grep "pattern" | wc
ls | sort | uniq
"unclosed quote     # Syntax error: unclosed quote
'unclosed quote     # Syntax error: unclosed quote
ls | grep "a"
echo $NONEXISTENT      # Should print nothing
cat                 # Then press Ctrl+D
./infinite_loop     # Then press Ctrl+C
export a=           # sets variable with an emtpy string
export a="b"=c     # Multiple equal signs
export 123=456     # Invalid variable name
empty command --> gives new prompt
exit with multiple args
- echo $PWD$HOME         # Concatenated variables --> only expands first
- waits for input when cat without arg is involved, should fail instead? e.g. same in bash: cat | cat | ls  --> prints ls OK
- cat     # Then press Ctrl+C -> exits but concatenates with the next prompt ^Cmariashell >
exit str --> prints correct error but does not exit the shell (mariashell: exit fds: numeric argument required)
exit without args : exits but with leaks
exit multple args -> no error

UNTESTED:

3. Check exit status ($?) after each command
4. Verify memory leaks using Valgrind

7. Check environment variable modifications persist correctly


Here-strings with <<<
(a variant of <<, note the triple less-than)

    cat <<< "single line of input"

    passes a single string directly to stdin.

//todo add test case: > cannot be the last symbol in a valid redirection in Bash.

Out of scope:

<<<	here-string (single-line stdin)
n>>file	append file descriptor n to file
n<<word	here-document for file descriptor n



Return value of a process

  - Execute a simple command with an absolute path like /bin/ls or any other command with arguments but without
  quotes and double quotes then execute echo $?
  - Check the printed value. You can repeat the same in bash and compare it.
  - Repeat multiple times with different commands and arguments, use some failing commands like '/bin/ls
  filethatdoesntexist'
  - anything like expr $? + $?
  - if something crashes use the crash flag.
  - if something is not working use the incomplete work flag.

Signals

- Try ctrl-C in an empty prompt should show a new line with a new prompt
- Try ctrl-\ in an empty prompt should not do anything
- Try ctrl-D in an empty prompt should quit minishell --> RELAUNCH!
- Try ctrl-C in a prompt after you wrote some stuff should show a new line with a new prompt
- Try ctrl-D in a prompt after you wrote some stuff should not do anything
- Try ctrl-\ in a prompt after you wrote some stuff should quit minishell --> RELAUNCH!
- Try ctrl-C after running a blocking command like cat or grep without arguments
- Try ctrl-\ after running a blocking command like cat or grep without arguments
- Try ctrl-D after running a blocking command like cat or grep without arguments
- Repeat multiple times with different commands
- if something crashes use the crash flag.
- if something is not working use the incomplete work flag.

Double Quotes

- Execute commands with simple quotes as an argument
- Try empty arguments
- Try environment variables, whitespaces, pipes, redirection in the simple quotes
- echo '$USER' must print $USER
- Nothing should be interprated

env

- Check if env shows you the current environment variables

export

- Export environment variables, create new ones, and replace old ones
- Check them with env

unset

- Export environment variables, create new ones, and replace old ones
- Use unset to remove some of them
- Check the result with env

cd

- Use the command cd to move the working directory and check if you are in the right directory with /bin/ls
- Repeat multiple times with working and not working cd
- try '.' '..' as arguments too

pwd

- Use the command pwd
- Repeat multiple times in multiple directories

Relative Path

- Execute commands but this time use a relative path
- Repeat multiple times in multiple directories with a complex relative path (lots of ..)
- Execute commands but this time without any path. (ls, wc, awk etc...)
- Unset the $PATH and check if it is not working anymore
- Set the $PATH to a multiple directory value (directory1:directory2) and check that directories are checked in order
  from left to right

Redirection

- Execute commands with redirections < and/or >
- Repeat multiple times with different commands and arguments and sometimes change > with >>
- Check if multiple of the same redirections fail
- Test << redirection (it doesn't need to update history).

Pipes

- Execute commands with pipes like 'cat file | grep bla | more'
- Repeat multiple times with different commands and arguments
- Try some failing commands like 'ls filethatdoesntexist | grep bla | more'
- Try to mix pipes and redirections.

Go Crazy and history

- type a command line then use ctrl-C then press enter the buffer should be clean and nothing try to execute.
- Can we navigate through history with up and down and retry some command
- Execute commands that should not work like 'dsbksdgbksdghsd' and check if the shell doesn't crash and prints an
  error
- Try to execute a long command with a ton of arguments
- Have fun with that beautiful minishell and enjoy it
// check for EOL is pipe (starts multiline input) --> invalid command --> check if last cmd has no args


Environment Variables

- Execute echo with some $ variables as argumentss
- Check that $ is interprated as an environment variable
- Check that double quotes interpolate $
- Check that $USER exist or set it.
- echo "$USER" should print the value of $USER

BONUS

    And, Or

    - Use &&, || and parenthesis with commands and check if it works as bash

WildCard

 - Use wildcards in arguments for the local directory.

Surprise (or not...)

- set USER environment variable.
- Test echo "'$USER'" this should print 'USER_VALUE'
- Test echo '"$USER"' this should print "$USER"


cat <<    # comment
'EOF'
Because:
    Bash sees the # as a comment and ignores the rest of the line.
    So the << appears to be dangling — and you'll get a syntax error.

If any part of the delimiter is unquoted, then:
    Variable expansion, command substitution, and backslash
     interpretation will happen in the here-document body.

--> todo expand vars in heredoc if not quoted

cat << EOF > file1.log
cat [stdin from heredoc] > file1.log
Flow:  parse all redirections (input or output) and apply them accordingly after processing the heredoc delimiter and content.
stdin  ← heredoc buffer
stdout → file1.log

https://42born2code.slack.com/archives/C04KYC9QCDQ/p1752526150488059
The heredoc delimiter doesn't expand variables but the content inside the heredoc expands. And quotes aren't removed inside the heredoc


- multiple heredocs (last one first, keep goinf with seecond, then process)


export "test=""echo hello | cat" --> for $test: hello | cat
export test="echo hello | cat" --> for $test: hello | cat
